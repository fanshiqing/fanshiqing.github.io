<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[L04-Mutual Exclusion]]></title>
    <url>%2F2017%2F10%2F19%2FL04-Mutual-Exclusion%2F</url>
    <content type="text"><![CDATA[Preface The MUTEX problem the shared memory model problem definition The unbounded algorithm The bakery algorithm The unbounded algorithm Shared Memory ModelProcesses communicate via a set of shared variables (also called shared registers), each shared variable has a type, defining a set of primitive operations (performed atomically) Several types of shared variable can be employed, e.g. read/write read-modify-write (RMW) compare&amp;swap (CAS) Each register has a type, which specifies: Values to be taken on by registers Operations performed on the registers Values to be returned by operations (if any) New values of the register resulting from the operation A configuration in the shared memory model is a vector: C = where q_i is a state of p_i and r_j is a value of register R. The events in a shared memory system are: computation steps taken by the processors and are denoted by the index of the processor; At each computation step, the shared variable is accessed. In asynchronous shared memory systems, an execution is admissible if each processor has an infinite number of computation steps. Complexity measuresObviously in shared memory systems there are no messages to measure. Instead we focus on the space complexity, the amount of shared memory needed to solve problems. Number of distinct shared variables required and the amount of shared space (e.g., # of bits) Changes from the MSG model Communication medium changes No inbuf and outbuf state components Configuration includes values for shared variables Execution manner changes One event type: one computation step by a process pi’s state in old configuration specifies which shared variable is to be accessed and with which primitive shared variable’s value in the new configuration changes according to the primitive’s semantics pi’s state in the new configuration changes according to its old state and the result of the primitive The Mutual Exclusion ProblemEach processor’s code is divided into four sections: Entry (trying): the code executed in preparation for entering the critical section Critical: the code to be protected from concurrent execution Exit (release): the code executed on leaving the critical section Remainder: the rest of the code Each processor cycles through these sections in the order: remainder –&gt; entry –&gt; critical –&gt; exit –&gt; remainder. An algorithm for a shared memory system solves the mutual exclusion problem with no deadlock (or no lockout) if the following holds (three properties): Mutual exclusion: In every configuration of every execution, at most one processor is in the critical section. No deadlock: In every admissible execution, if some processor is in the entry section in a configuration, then there is a later configuration in which some processor is in the critical section. No lockout: In every admissible execution, if some processor is in the entry section in a configuration, then there is a later configuration in which that same processor is in the critical section. Mutex progress conditions: no deadlock no lockout bounded waiting: no lockout + while a processor is in its entry section, other processors enter the critical section no more than a certain number of times. These three conditions are increasingly strong. The code for the entry and exit sections is allowed to assume that: no processor stays in its critical section forever shared variables used in the entry and exit sections are not accessed during the critical and remainder sections Mutual Exclusion Using Powerful PrimitivesWe will show that one bit suffices for guaranteeing mutual exclusion with no deadlock while O(logn) bits are necessary (and sufficient) for providing stronger fairness properties. Binary Test&amp;Set RegistersThe test&amp;set operation atomically reads and updates the variable. There is a simple mutual exclusion algorithm with no deadlock that uses one test&amp;set register(Algorithm 7). One processor could always grab V (i.e., win the test&amp;set competition) and starve the others. No Lockout does not hold. Thus Bounded Waiting does not hold. Read-Modify-Write RegisterszThe RMW operation read-modify-write all in one atomic operation.Clearly, the test&amp;set operation is a special case of rmw, where f(V) = 1 for any V. Detailed analysis about algorithm 8 please refer to the textbook. Mutual Exclusion Using Read/Write RegistersThe Bakery AlgorithmBasic idea: Tell others “I want to enter the critical section” Get tickets and wait for my turn We employ the following shared data structures: Number: an array of n integers, which holds in its ith entry the number of p_i Choosing: an array of n Boolean values; Choosing[i] is true while p_i is in the process of obtaining its number. Because several processors can read Number concurrently it is possible for several procesors to obtain the same number!. To break symmetry, we define p_i&#39;s ticket be the pair (Number[i], i) （uniqueness）(tickets之间的序比较可以使用字典序). Algorithm 10 provides mutual exclusion and no lockout. (proof pls refer to the textbook) The numbers can grow without bound, unless when every processor is in the remainder section. How to achieve MUTEX when variables have finite size. A Bounded Mutual Exclusion Algorithm for 2 ProcessorsAlgorithm 11 provides mututual exclusion and no deadlock for two processors p_0 and p_1. Each processor p_i has a Boolean shared variable Want[i]. Want[i]=1: if p_i wants to enter the critical section. However, the algorithm gives prioirty to one of the processors and the other one can starve. We then convert this algorithm to one that provides no lockout as well.To achieve no lockout, we modify the alrgorithm so that instead of always giving priority to p_0, each processor gives priority to the other processor on leaving the critical section. Priority: Shared variable, contains the id of the processor that has the priority at the moment. In the entry, wait until: Case 1: the other processor has the priority (but does not want to enter the critical section) Case 2: I have the priority. A Bounded Mutual Exclusion Algorithm for n Processors (recursively use the [2, no lockout] algorithm)To construct a solution for the general case of n processors we employ the algorithm for two processors. Proceessors compete pairwise, using the two-processor algorithm described above, in a tournament tree (锦标赛树) arrangement. The pairwise competitions are arranged in a complete binary tree. Each processor begins at a specific leaf of the tree. At each level, the winner gets to proceed to the next higher level, where it competes with the winner of the competition on the other side of the tree. The processor that wins at the root enters the critical section. v: node number; we associate shared variable Want^v[0], Want^v[1], and Priority^v (all initialized to 0) To begin the competition for the (real) critical section, processor p_i executes Node(2^k + i/2, i mod 2) note that the leaves of the tree are numbered 2^k, 2^k + 1, …, 2^(k+1) - 1 (see Fig. 4.7). the processor on the left (right) side play the role of p_0 (p_1) References[1] Attiya, Hagit, and Jennifer Welch. Distributed computing: fundamentals, simulations, and advanced topics. Vol. 19. John Wiley &amp; Sons, 2004.]]></content>
      <categories>
        <category>Introduction to Distributed Algorithms</category>
      </categories>
      <tags>
        <tag>分布式算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L03-Leader Election in Rings]]></title>
    <url>%2F2017%2F10%2F12%2FL03-Leader-Election-in-Rings%2F</url>
    <content type="text"><![CDATA[Discuss the leader election (LE) problem in message-passing systems for a ring topology, in which a group of processors must choose one among them to be a leader. Present the different algorithms for leader election problem by taking the cases like anonymous/non-anonymous rings, uniform/non-uniform rings and synchronous/asynchronous rings etc. [Based on the book “Distributed Computing“ by Hagit attiya &amp; Jennifer Welch] Ring Networks In an oriented ring, processors have a consistent notion of left and right. For example, if messages are always forwarded on channel 1, they will cycle clockwise around the ring. Why study rings? simple starting point, easy to analyze abstraction of a token ring lower bounds and impossibility results for ring topology also apply to arbitrary topoligies. The Leader Election (LE) Problem LE problem is for each processor to decide that either it is the leader or non-leader, subject to the constraint that exactly one processor decides to be the leader. LE problem represents a general class of symmetry-breaking problems. For example, when a deadlock is created, because of processors waiting in a cycle for each other, the deadlock can be broken by electing one of the processor as a leader and removing it from the cycle. Each processor has a set of elected (won) and not-elected (lost) states. Once an elected state is entered, processor is always in an elected state (and similarly for not-elected): i.e., irreversible decision. In every admissible execution: every processor eventually enters an elected or a not-elected state exectly one processor (the leader) enters an elected state. Uses of LE A leader can be used to coordinate activities of the system: find a spanning tree using the leader as the root; reconstruct a lost token in a token-ring network. Uniform (Anonymous) Algorithms Anonymous or not: A leader election algorithm is anonymous if processors do not have unique identifiers that can be used by the algorithm Message recipients can only be specified in terms of channel labels, e.g., left and right neighbors ==&gt; Every processor in the system has the same state machine. A uniform algorithm does not use the ring size (same algorithm for each size ring) Formally, every processor in every size ring is modeled with the same state machine Uniform: since the algorithm looks the same for every value of n. A non-uniform algorithm uses the ring size (different algorithm for each size ring) Formally, for each value of n, every processor in a ring of size n is modeled with the same state machine An . Leader Election in Anonymous RingsTheorem: For nonuniform algorithms and synchronous rings, there are no anonymous LE algorithms. Proof Sketch: Every processor begins in same state with same outgoing msgs (since anonymous) Every processor receives same msgs, does same state transition, and sends same msgs in round 1 Ditto for rounds 2,3,… Eventually some processor is supposed to enter an elected state. But then they all would. Proof sketch shows that either safety (never elect more than one leader) or liveness (eventually elect at least one leader) is violated. Since the theorem was proved for non-uniform and synchronous rings, the same result holds for weaker (less well-behaved) models (uniform / asynchronous). Lattice) (格）A lattice is an abstract structure studied in the mathematical subdisciplines of order theory and abstract algebra. It consists of a partially ordered set in which every two elements have a unique supremum (上确界) (also called a least upper bound or join, a ∧ b) and a unique infimum （下确界）(also called a greatest lower bound or meet, a V b) Based on the impossibility result, we can reasonably assume that: Rings with unique processor identifiers. LE in Asynchronous RingsThere exists algorithms when nodes have unique ids. We will evaluate them according to their message complexity. Brute Force LE123456789Send value of own id to the left.When receive an id j (from the right) if j &gt; id then forward j to the left // this processor has lost if j == id then elect self // this processor has won if j &lt; id then // do nothing (swallow) Analysis Correctness: Elect processor with the largest id. (Time: O(n)) Message complexity: Depends on how the ids are arranged. largest id travels all around the ring (n msgs) 2nd largest id travels until reaching largest 3rd largest id travels until reaching largest or second largest. etc. Worst way to arrange the ids is in decreasing order (Fig.3.2) The O(n^2) algorithm is simple and works in both sync and async model. But how to optimize? Idea: try to have message containing smaller ids travel smaller distance in the ring. k-neighbour Forwarding Basic idea Gradually increase the scope of sending Eliminate unnecessary senders accordingly Smaller IDs are swallowed Clever forwarding k-neighbourhood 2k+1 nodes: k left + k right + self in the kth phase, LE among the 2^k-neighborhood size of neighbourhood doubles in each phase only the winner survives to the next phase Analysis Correctness: similar to O(n*2) algorithm Message complexity Each msg belongs to a particular phase and is initiated by a particular proc. Probe distance in phase k is 2^k Number of msgs initiated by a proc. in phase k is at most 4 * 2^k (probes and replies in both directions) How many proc. initiate probes in phase k ? For k = 0, every proc. does For k &gt; 0, every proc. that is a “winner” in previous phase (phase k-1) does Maximum number of phase k-1 winners occurs when the are packed as densely as possible: Total number of phase k-1 winners is at most n/(2^(k-1) + 1) How many phases are there? let n/2^(k-1) + 1 == 1 (at the last phase there exists only one winner) ==&gt; k = log(n-1) + 1 = number of phases So the total number of msgs is sum, over all phases, of number of winners at that phase times number of msgs originated by that winner: The O(log n) algorithm is more complicated than the O(n^2) algorithm but uses fewer messages in worst case. Lower bound for LE AlgorithmCan we do better than O(nlogn) ? Theorem: Any leader election algorithm for asynchronous rings whose size is not known a priori has Ω(nlog n) msg complexity (holds also for undirectional rings). The two algorithms above are comparison-based algorithms, i.e. they use the identifiers only for comparison (&lt;, &gt;, =) In synchronous networks, O(n) msg complexity can be achieved if general arithmatic operations are permitted (non-comparison based) and if time complexity is unbounded. References[1] Attiya, Hagit, and Jennifer Welch. Distributed computing: fundamentals, simulations, and advanced topics. Vol. 19. John Wiley &amp; Sons, 2004.[2] 分布式算法（黄宇）课程主页[3] Distributed System]]></content>
      <categories>
        <category>Introduction to Distributed Algorithms</category>
      </categories>
      <tags>
        <tag>分布式算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L02-Basic Message Passing Algorithms]]></title>
    <url>%2F2017%2F10%2F05%2FL02-Basic-Message-Passing-Algorithms%2F</url>
    <content type="text"><![CDATA[Broadcast / convergecast on a spanning tree Async / sync flooding to construct a spanning tree distributed DFS with/without a specific root Broadcast over a rooted spanning tree Broadcast is used to send the information to all. Suppose processors already have information about a rooted spanning tree of the communication topology tree: connected graph with no cycles spanning tree: contains all processors rooted: there is a unique root node Implemented via parent and children local varialbes at each processor. indicate which incident channnels lead to parent and children in the rooted spanning tree. Spanning Tree: A tree is a connected undirected graph with no cycles. It is a spanning tree of a graph G if it spans G (that is, it includes every vertex of G) and is a subgraph of G (every edge in the tree belongs to G). A spanning tree of a connected graph G can also be defined as a maximal set of edges of G that contains no cycle, or as a minimal set of edges that connect all vertices. Complexity analysis: Synchronous model Time complexity: time is depth d of the spanning tree. (at most n-1 when chain) MSG complexity: number of messages is n-1, since one message is sent over each spanning tree edges. Aysnchronous model Same as synchronous model. Convergecast (from leaves to the root) Convergecast is used to collect the information. Again, suppose a rooted spanning tree has already been computed by the processors parent and children variables at each processor Do the opposite of broadcast leaves send msgs to their parents. non-leaves wait to get msgs from each child, then send combined (aggregate) info to parent. Finding a Spanning Tree Given a Root by Flooding Flooding): Flooding is a simple computer network routing algorithm in which every incoming packet is sent through every outgoing link except the one it arrived on. root send M to all its neighbours when non-root first gets M, set the sender as its parent send “parent” msg to sender send M to all other neighbours (if no other neighours, then terminate) when get M otherwise, send “reject” to sender. use “parent” and “reject” msgs to set children varialbes and know when to terminate (after hearing from all neighbours) Execution of spanning tree algorithm In the synchronous model: always gives breadth-first search (BFS) tree. Asynchronous: not necessarily BFS tree. Both models achieves O(m) messages complexity and O(diam) time complexity. Diameter D of a network is defined as the longest path of the shortest paths between any two nodes. Distributed DFS with a Specified Root Basic rationale: sequential execution over a distributed system (of multiple processors) Distributed DFS without a Specified Root Assume the processors have unique identifiers (otherwise impossible!) Idea: Each processor starts running a copy of the DFS spanning tree algorithm, with itself as root tag each msg with initiator’s id to differentiate when copies “collide”, copy with larger id wins. Message complexity: O(n*m) Time complexity: O(m) (m: edges in graph) References[1] Attiya, Hagit, and Jennifer Welch. Distributed computing: fundamentals, simulations, and advanced topics. Vol. 19. John Wiley &amp; Sons, 2004.[2] 分布式算法（黄宇）课程主页[3] Distributed System]]></content>
      <categories>
        <category>Introduction to Distributed Algorithms</category>
      </categories>
      <tags>
        <tag>分布式算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L01-Model of Computation]]></title>
    <url>%2F2017%2F09%2F27%2FL01-Model-of-Computation%2F</url>
    <content type="text"><![CDATA[Async/sync system Random access machine model Message passing model Shared memory model Essential Issues of Alogrithm Model of computation Algorithm design Algorithm analysis Asynchronous &amp; Synchronous System Asynchronous System. A system is said to be asynchronous if there is no fixed upper bound on how long it takes for a message to be delivered (message delays) or how much time elapses between consectutive steps of a processor (processor step time) [1]. Synchronous System. In the synchronous model processors execute in lockstep: The execution is partitioned into rounds, and in each round, every processor can send a message to each neighbour, the messages are delivered, and every processor computes based on the messages just received. (This model is convenient for designing algorithms) [1] Why asynchronous systems? Sometimes the upper bounds are quite large, are infrequently reached and change over time. It is often desiable to design an algorithm that is independent of any particular timing parameters, namely an asynchronous algorithm Instead of design an algorithms that depends on the bounds Random Access Machine (RAM) ModelThe goal of working with a model computer instead of a real computer is that we want to have a machine, which is as easy as possible, but still let us capture the main aspects of a real computer. This model of computation is an abstraction that allows us to compare algorithms on the basis of performance. Simplifications for RAM model: Simple operations take only 1 time step; Loops and subroutines are not simple operations; We assume we have as much memory as we need (infinite storage); Memory access is considered to be free in terms of time (or one time step?); A unit of memory cannot hold an arbitrarily large number. The RAM model takes no notice of whether an item is in cache or on the disk, which simplifies the analysis. It is an excellent model for understanding how an algorithm will perform on a real computer. It strikes a fine balance by capturing the essential behavior of computers while being simple to work with. We use the RAM model because it is useful in practice. Relationship between the Turing Machine and RAM ModelsA random-access machine with unbounded indirection is equivalent to a Turing machine. Informally speaking, both machines have the same computational capabilities. (wikipedia | Equivalance of RAM and Turing Machines) Message Passing ModelThe architecture is used to communicate data among a set of processors without the need for a global memory. Each processor has its own local memory and communicates with other Processors using message. Data exchanged among processors cannot be shared; it is rather copied (using send/receive messages). An important advantage of this form of data exchange is the elimination of the need for synchronization constructs, such as semaphores, which results in performance improvement. Shared Memory ModelBoth SMP and DSM are shared address space platforms. Symmetric Multiprocessors (SMP)Processors all connected to a large shared memory. Examples are processors connected by crossbar, or multicore chips. It is symmetric because the access time from any of the CPUs to memory is the same. Key characteristics is uniform memory acess (UMA).Caches are a problem: need to be kept coherrent = when one CPU changes a value in memory, then all other CPUs will get the same value when they access it. All caches will show a coherent value. Distributed Shared Memory (DSM)DSM is basically an abstraction that integrates the local memory of different machine into a single logical entity shared by cooperating processes. The distributed shared memory implements the shared memory model in distributed systems, which have no physical shared memory. (shared memory exists only virtually, similar concepts to virtual memory) The shared memory model provides a virtual address space shared between all nodes The overcome the high cost of communication in distributed systems, DSM systems move data to the location of access. How? Data moves between main memory and secondary memory (within a node) and between main memories of different nodes. Each data object is owned by a node Initial owner is the node that created object Ownership can change as object moves from node to node When a process accesses data in the shared address space, the mapping manager maps shared memory address to physical memory (local or remote). Shared Memory v.s. Message Passing Messsge Passing Shared Memory who does communication Programmer Automatic Data distribution Manual Automatic HW support Simple Extensive (automatically figures out when to send data, to whom and where to cache in, etc.) Programming Correctness Difficult Less Difficult Performance Difficult (noce you get correctness, performance is not far away) Very Difficult References[1] Attiya, Hagit, and Jennifer Welch. Distributed computing: fundamentals, simulations, and advanced topics. Vol. 19. John Wiley &amp; Sons, 2004.[2] 分布式系统(Distributed System)资料[3] Shared Memory, NYU Computer Science[4] 分布式算法（黄宇）课程主页[5] Message Passing Vs Shared Memory - Georgia Tech - HPCA: Part 5]]></content>
      <categories>
        <category>Introduction to Distributed Algorithms</category>
      </categories>
      <tags>
        <tag>分布式算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[htop - interactive process viewer]]></title>
    <url>%2F2017%2F06%2F18%2Fhtop%2F</url>
    <content type="text"><![CDATA[htop命令简介htop是Linux系统下的一个交互式、实时进程监控应用程序，top的高级版。 优点： 可以横向或纵向滚动浏览进程列表，以便查看所有的进程和完整的命令行 支持鼠标操作 杀进程时不需要输入进程号(快捷键: F9) htop vs top It is similar to top, but allows you to scroll vertically and horizon- tally, so you can see all the processes running on the system, along with their full command lines, as well as viewing them as a process tree, selecting multiple processes and acting on them all at once.Tasks related to processes (killing, renicing) can be done without entering their PIDs. (摘自htop手册:) 安装For Mac OS: 1$ brew install htop For Ubuntu 14.04 LTS: 1$ sudo apt-get install htop 查看命令手册： 1$ man htop 启动htop： 1$ htop 将得到如下类似的一个实时进程监控窗口： 帮助：按F1进入使用帮助。 退出：按下q键退出htop面板。 监控面板介绍系统CPU使用率 图中上半部分中的数字1到8表示系统中CPU/Core的数量，而紧邻数字的右侧进度条则相应地表示了对应CPU/Core的实时负载。进度条中不同颜色具有不同的含义(以下为默认配置，具体操作时可以在F2-&gt;Setup-&gt;Colors列表中选择不同的主题)： CPU使用率栏: [低优先级进程/用户进程/内核进程 &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; used%] 系统内存使用率 Memory使用率栏：[已使用/buffers/cache &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; used/total] 系统平均负载 负载(Load)): 运行队列(run-queue)的长度：L = 等待进程的数目 + 运行进程的数目 平均负载(load average) 在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息，也就是CPU使用队列的长度的统计信息 “最大负载=核心数”法则 在多核处理中，负载不应该高于处理器核心的总数量。source 上图中Load average之后的3个数字显示的是系统在1分钟，5分钟，15分钟之内的平均负载值。(注： uptime命令可以直接查看load average) 进程详细实时信息列表 每一列依次表示： PID 进程ID USER 进程的所有者 PRI 进程优先级。数字越小，优先级越高。 NI 进程的nice值（负值表示高优先级，正值表示低优先级） VIRT 进程使用的虚拟内存 RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA S 进程状态 R (Running) &ensp; &ensp; 可执行状态（运行/就绪) D (uninterruptedly sleeping) &ensp; &ensp; 不可中断的睡眠状态.通常是在等待IO，比如磁盘IO，网络IO，其他外设IO (该状态不接收外来的任何信号，因此无法用kill杀掉D状态的进程) S (sleeping) &ensp; &ensp; 可中断的睡眠状态(因为等待某某事件的发生(比如等待socket连接、等待信号量),而被挂起) T (traced) &ensp; &ensp; 暂停状态或跟踪状态 (例如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于task_traced状态) Z (zombied) &ensp; &ensp; 退出状态，进程成为僵尸进程(已经结束了的进程，但是没有从进程表中删除) CPU% 进程的CPU时间片利用率 MEM% 进程的物理内存利用率 TIME+ 进程使用的处理器时间总计 Command 启动该进程的完整命令行 最后一行是F1~F10的功能菜单和对应的字母快捷键。 Read MoreUnderstanding the Load Average on Linux and Other Unix-like SystemsUnderstanding Linux CPU Load - when should you be worried?Understanding and using htop to monitor system resourcesLinux Performance Tools]]></content>
      <categories>
        <category>Linux性能分析工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础]]></title>
    <url>%2F2017%2F06%2F15%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[function doDecrypt(pwd, onError) { console.log("in doDecrypt"); var txt = document.getElementById("enc_content").innerHTML; var plantext; try { var bytes = CryptoJS.AES.decrypt(txt, pwd); plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) {onError(err);} return; } document.getElementById("enc_content").innerHTML = plaintext; document.getElementById("enc_content").style.display = "block"; document.getElementById("enc_passwd").style.display = "none"; } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【闲情】记 第二届南大上海校友会新年羽毛球嘉年华]]></title>
    <url>%2F2017%2F01%2F07%2F%E9%97%B2%E6%83%85-%E8%AE%B0%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%8D%97%E5%A4%A7%E4%B8%8A%E6%B5%B7%E6%A0%A1%E5%8F%8B%E4%BC%9A%E6%96%B0%E5%B9%B4%E7%BE%BD%E6%AF%9B%E7%90%83%E5%98%89%E5%B9%B4%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[Abstract 时间： 2017年1月7日 地点：上海财大（武川路校区）羽毛球馆（旧馆） 事件：第二届南大上海校友会新年羽毛球嘉年华活动 角色：第二次参加这个活动，本次担任 杨浦队 队长 ^_^ 赛制：趣味赛 + 团体赛 赛果：杨浦队在8支参赛队中勇夺 第4名 (历史最好成绩)！ 趣味赛: 单手颠球，穿越障碍 三人隔网，你发我接（限时） 团体赛(8支) 徐汇、闵松、沿江、张江、花木、杨浦、长静黄联队、市北联队 赛后聚餐地点：上海财大豪生酒店 赛前宣传海报(感谢@陈雨致 学姐的精心设计)： 赛前集体合影(每队一列，列首为该队队长): 高质量的比赛场馆(感谢@王绍立学长大力帮助联系和提供场地！): 比赛中： 赛果: 冠军：闵松队(根据约定，本次比赛冠军将负责主办明年的第三届比赛^_-) 亚军：沿江队 季军：张江队 殿军：杨浦队 赛后各队队长、裁判、志愿者们合影: 大杨浦队赛后合影留念 赛后聚餐: 广告时间感谢炜觉资本对本次活动的大力赞助！ 明年再来，闵松主办！]]></content>
      <categories>
        <category>闲情</category>
      </categories>
      <tags>
        <tag>闲情</tag>
        <tag>羽毛球</tag>
        <tag>相册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CaffeNet vs CaffeOnSpark]]></title>
    <url>%2F2016%2F05%2F12%2FCaffeNet-vs-CaffeOnSpark%2F</url>
    <content type="text"><![CDATA[SparkNetSparkNet 是由amplab开发的基于Spark的分布式深度神经网络架构，2015年11月份在github上开源. 该系统开发的动机在于当下流行的批处理计算框架（MapReduce、Spark等）都不是设计用来支持已有的分布式深度学习系统下的异步的、通行密集型的任务。SparkNet将已有的数据处理框架（Spark)和流行的、高效的深度学习框架Caffe整合到一起，同时提供了Spark RDDs和Caffe的访问接口；并通过改进的并行化SGD算法来降低节点间的通信开销[1]. SparkNet的架构示例如图1所示[1]。 图1是由5个节点组成的EC2集群。其中Master节点负责向其余4各worker节点分发任务；每个worker在本地单独使用基于GPU的caffe来进行训练；本地训练结束后各个worker将参数回传给Master;Master收集各个worker的参数后做全局的处理（例如average）再broadcast给各个worker以进行下一轮的迭代。 CaffeOnSparkCaffeOnSpark 由Yahoo开发，并于今年2月份开源在github上。该系统旨在将深度学习步骤(训练、测试等)无缝地嵌入到Spark应用中，使得直接在存储数据的(强化的)Hadoop集群上进行深度学习成为可能，从而避免了数据在Hadoop集群和深度学习集群之间不必要的传输. 作为Spark的深度学习包，CaffeOnSpark填补了Spark MLlib在DL能力上的不足[3]。可以这样说，CaffeOnSpark集合了Caffe和Spark两者之长，并应用到大规模深度学习上，使得我们能像操作其他Spark应用一样操作深度学习任务。 CaffeOnSpark的系统架构图如图2[6] 所示： &ensp;&ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp; &ensp; &ensp; &ensp; &ensp;图2. CaffeOnSpark System Architecture 从图2中我们看到CaffeOnSpark在参数的同步/管理操作上和SparkNet是完全不同的：CaffeOnSpark executors之间通过MPI_ALLREDUCE接口通信（通过底层RDMA/Infiniband 或者TCP/Ethenet来保证GPU间高速的数据传输,10x于CPU).在这种通信模式下，各个节点/Caffe引擎之间是peer-to-peer的模式；而SparkNet的设计中依然保留了Spark的主/从模式。 小结CaffeOnSpark和SparkNet的相同之处在于两者都使得Spark集群下基于Caffe的深度学习成为可能。 而两者最显著的不同在于两者在系统框架设计中对于参数同步所采用的不同方案。 参考资料[1]. Moritz,Philipp, et al. “SparkNet: Training Deep Networks in Spark.” arXiv preprint arXiv:1511.06051 (2015).[2]. Large Scale Distributed Deep Learning on Hadoop Clusters, PPT[3]. GitHub - amplab/SparkNet, https://github.com/amplab/SparkNet[4]. GitHub - yahoo/CaffeOnSpark, https://github.com/yahoo/CaffeOnSpark[5]. CaffeOnSpark Google Group, https://groups.google.com/forum/#!forum/sparknet-users[6]. Large Scale Distributed Deep Learning on Hadoop Clusters]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习框架</tag>
      </tags>
  </entry>
</search>